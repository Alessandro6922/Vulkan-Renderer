#version 460
#extension GL_EXT_mesh_shader : require

const uint grassCount = 65536;
const float RANDOM_HEIGHT_SCALE = 0.7;
const uint clumpRadius = 1;
const float spacing = 1;
const float PI = 3.1415;

layout(set = 0, binding = 0) uniform UniformBufferObject {
	mat4 model;
	mat4 view;
	mat4 proj;
} ubo;

layout(set = 0, binding = 1) uniform GrassDataBufferObject{
	float elapsedTime;
	float grassLean;
	float grassHeight;
	float bladeThickness;
	float curveStrength;
	float windStrength;
	float windSpeed;
	float maxDistance;
	vec4 camPosition;
	vec4 bezierEndPoint;
} gdbo;

layout(std430, set = 0, binding = 2) readonly buffer GrassPositionsSSBOIn{
	vec4 position[grassCount];
	vec4 groundNormal[grassCount];
} ssbo;

//struct meshTaskPayload {
//	vec3 col;
//};
//
//taskPayloadSharedEXT meshTaskPayload payload;

layout(location = 0) out vec3 fragColour[];
layout(location = 1) out vec2 fragTexCoord[];
layout(location = 2) out vec3 normal[];

vec3 bezier(vec3 A, vec3 B, vec3 C, float t) {
  vec3 E = mix(A, B, t);
  vec3 F = mix(B, C, t);
  vec3 G = mix(E, F, t);

  return G;
}

vec3 bezierDerivative(vec3 p0, vec3 p1, vec3 p2, float t) {
    return 2.0 * (1.0 - t) * (p1 - p0) + 2.0 * t * (p2 - p1);
}

// https://github.com/klejah/ResponsiveGrassDemo/blob/6ce514717467acc80fd965a6f7695d5151ba8c03/ResponsiveGrassDemo/shader/Grass/GrassUpdateForcesShader.cs#L67
void MakePersistentLength(in vec3 groundPos, inout vec3 v1, inout vec3 v2, in float height) {
    //Persistent length
    vec3 v01 = v1 - groundPos;
    vec3 v12 = v2 - v1;
    float lv01 = length(v01);
    float lv12 = length(v12);


    float L1 = lv01 + lv12;
    float L0 = length(v2 - groundPos);
    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 = groundPos + v01;
    v2 = v1 + v12;
}

//utils https://github.com/GPUOpen-LibrariesAndSDKs/WorkGraphsMeshNodeSample/blob/main/meshNodeSample/shaders/utils.hlsl

uint Hash(uint seed)
{
	seed = (seed ^ 61u) ^ (seed >> 16u);
	seed *= 9u;
	seed = seed ^ (seed >> 4u);
	seed *= 0x27d4eb2du;
	seed = seed ^ (seed >> 15u);
	return seed;
}

uint CombineSeed(uint a, uint b)
{
	return a ^ Hash(b) + 0x9e3779b9 + (a << 6) + (a >> 2);
}

uint CombineSeed(uint a, uint b, uint c)
{
	return CombineSeed(CombineSeed(a, b), c);
}

uint CombineSeed(uint a, uint b, uint c, uint d)
{
	return CombineSeed(CombineSeed(a, b), c, d);
}

uint Hash(in float seed)
{
	return Hash(uint(seed));
}

uint Hash(in vec3 vec)
{
	return CombineSeed(Hash(vec.x), Hash(vec.y), Hash(vec.z));
}

uint Hash(in vec4 vec)
{
	return CombineSeed(Hash(vec.x), Hash(vec.y), Hash(vec.z), Hash(vec.w));
}

float Random(uint seed)
{
	return Hash(seed) / float(~0u);
}

float Random(uint a, uint b)
{
	return Random(CombineSeed(a, b));
}

float Random(uint a, uint b, uint c)
{
	return Random(CombineSeed(a, b), c);
}

float Random(uint a, uint b, uint c, uint d)
{
	return Random(CombineSeed(a, b), c, d);
}

float Random(uint a, uint b, uint c, uint d, uint e)
{
	return Random(CombineSeed(a, b), c, d, e);
}

// https://gpuopen.com/learn/mesh_shaders/mesh_shaders-procedural_grass_rendering/
int tsign(in uint gtid, in int id) {
    return ((gtid & (1u << uint(id))) != 0) ? 1 : -1;
}

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
layout(triangles) out;
layout(max_vertices = 256, max_primitives = 192) out;
void main(){
	uint overallWorkGroupID = gl_WorkGroupID.x + (gl_WorkGroupID.y * gl_NumWorkGroups.x);

	vec3 clumpCentre = ssbo.position[overallWorkGroupID].xyz;
	const vec3 clumpNormal = ssbo.groundNormal[overallWorkGroupID].xyz;
	const uint seed = CombineSeed(uint(int(clumpCentre.x / spacing)), uint(int(clumpCentre.z / spacing)));

	const int maxVerticesPerBladeEdge = 16;
	const int minVerticesPerBladeEdge = 3;

	float distanceFromCam = abs(length(gdbo.camPosition.xyz - clumpCentre));
	float maxDistanceFromCam = gdbo.maxDistance;
	const int actualVerticesPerBladeEdge = max(int(mix(maxVerticesPerBladeEdge, minVerticesPerBladeEdge, clamp(distanceFromCam / maxDistanceFromCam, 0.0, 1.0)) / 2) * 2, minVerticesPerBladeEdge);

	const int verticesPerBlade = 2 * actualVerticesPerBladeEdge;
	const int trianglesPerBlade = 2 * (actualVerticesPerBladeEdge - 1);
	const int maxBladeCount = 4;

	const int vertexCount = maxBladeCount * verticesPerBlade;
	const int triangleCount = maxBladeCount * trianglesPerBlade;

	SetMeshOutputsEXT(vertexCount, triangleCount);

	for(uint i = 0; i < 2; ++i){
		int vertID = int(gl_LocalInvocationID.x + gl_WorkGroupSize.x * gl_WorkGroupSize.y * i);

		if(vertID >= vertexCount) break;

		int bladeID = vertID / verticesPerBlade;
		int vertIDLocal = vertID % verticesPerBlade;

		const float height = gdbo.grassHeight + float(Random(seed, bladeID, 20)) * RANDOM_HEIGHT_SCALE;

		vec3 tangent = normalize(cross(vec3(0, 0, 1), clumpNormal));
		vec3 biTangent = normalize(cross(clumpNormal, tangent));

		float bladeDirectionAngle = 2.0 * PI * Random(seed, 4, bladeID);
		vec2 bladeDirection = vec2(cos(bladeDirectionAngle), sin(bladeDirectionAngle)) * gdbo.grassHeight * gdbo.grassLean;

		float offsetAngle = 2.0 * PI * Random(seed, bladeID);
		float offsetRadius = spacing * sqrt(Random(seed, 19, bladeID));
		vec3 bladeOffset = offsetRadius * (cos(offsetAngle) * tangent + sin(offsetAngle) * vec3(0, 0, 1));
		//bladeOffset -= clumpNormal * dot(bladeOffset, clumpNormal);
		//vec3 bladeOffset = offsetRadius * (cos(offsetAngle) * vec3(1, 0, 0) + sin(offsetAngle) * vec3(0, 0, 1));

		vec3 sideVec = normalize(vec3(bladeDirection.y, 0.0, -bladeDirection.x));
		vec3 offset = tsign(vertIDLocal, 0) * gdbo.bladeThickness * sideVec;

		vec3 p0 = clumpCentre + bladeOffset;
//		vec3 p1 = p0 + vec3(0.0, gdbo.grassHeight, 0.0) + gdbo.controlPointPull.xyz;
//		vec3 p2 = p1 + vec3(bladeDirection.x, 0.0, bladeDirection.y);

		vec3 p2 = p0 + vec3(0.0, gdbo.grassHeight, 0.0) + vec3(bladeDirection.x, 0.0, bladeDirection.y);
		vec3 p1 = p0 + ((p2 - p0) * 0.75) + cross(((p2 - p0) * 0.75), sideVec) * gdbo.curveStrength;

		MakePersistentLength(p0, p1, p2, gdbo.grassHeight);

		p0 += offset * 1.0;
		p1 += offset * 0.75;
		//p2 += offset * 0.1;

		int edgeID = vertIDLocal / 2;
		float t = (edgeID == actualVerticesPerBladeEdge - 1) ? 1.0 : float(edgeID) / float(actualVerticesPerBladeEdge - 1);
		vec3 vertexNormal = normalize(cross(sideVec, normalize(bezierDerivative(p0, p1, p2, t))));
		vec3 windOffset = vertexNormal * (sin(t + Random(bladeID) + gdbo.elapsedTime * gdbo.windSpeed)) * (t * t) * gdbo.windStrength;
		gl_MeshVerticesEXT[vertID].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(p0, p1, p2, t) + windOffset, 1.0);
		//fragColour[vertID] = vec3(Random(gl_WorkGroupID.x, 12, gl_WorkGroupID.y), Random(gl_WorkGroupID.y, 4, gl_WorkGroupID.x), Random(5, gl_WorkGroupID.y, gl_WorkGroupID.x));
		fragColour[vertID] = vec3(clamp(distanceFromCam / maxDistanceFromCam, 0.0, 1.0));
		normal[vertID] = vertexNormal;
		fragTexCoord[vertID] = vec2(tsign(vertIDLocal, 0), 1.0 - t);
	}

	for(uint i = 0; i < 2; ++i){
		int triID = int(gl_LocalInvocationID.x + gl_WorkGroupSize.x * gl_WorkGroupSize.y * i);
		
		if(triID >= triangleCount) break;

		int bladeID = triID / trianglesPerBlade;
		int triIDLocal = triID % trianglesPerBlade;

		int offset = bladeID * verticesPerBlade + 2 * (triIDLocal / 2);

		uvec3 triangleIndices = (triIDLocal & 1) == 0? uvec3(0, 1, 2) : uvec3(3, 2, 1);

		gl_PrimitiveTriangleIndicesEXT[triID] = offset + triangleIndices;
	}
}