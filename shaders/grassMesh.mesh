#version 460
#extension GL_EXT_mesh_shader : enable

const uint grassCount = 65536;
const float RANDOM_HEIGHT_SCALE = 0.7;
const uint clumpRadius = 1;
const float spacing = 3;
const float PI = 3.1415;

layout(set = 0, binding = 0) uniform UniformBufferObject {
	mat4 model;
	mat4 view;
	mat4 proj;
} ubo;

layout(set = 0, binding = 1) uniform GrassDataBufferObject{
	float elapsedTime;
	float grassLean;
	float grassHeight;
	float bladeThickness;
	vec4 controlPointPull;
	vec4 bezierCPoint2;
	vec4 bezierEndPoint;
} gdbo;

layout(std430, set = 0, binding = 2) readonly buffer GrassPositionsSSBOIn{
	vec4 position[grassCount];
	vec4 groundNormal[grassCount];
} ssbo;

layout(location = 0) out vec3 fragColour[];
layout(location = 1) out vec2 fragTexCoord[];
layout(location = 2) out vec3 normal[];
layout(location = 3) out vec3 clumpNormalOut[];

vec3 bezier(vec3 A, vec3 B, vec3 C, float t) {
  vec3 E = mix(A, B, t);
  vec3 F = mix(B, C, t);
  vec3 G = mix(E, F, t);

  return G;
}

vec3 bezierDerivative(vec3 p0, vec3 p1, vec3 p2, float t) {
    return 2.0 * (1.0 - t) * (p1 - p0) + 2.0 * t * (p2 - p1);
}

// https://github.com/klejah/ResponsiveGrassDemo/blob/6ce514717467acc80fd965a6f7695d5151ba8c03/ResponsiveGrassDemo/shader/Grass/GrassUpdateForcesShader.cs#L67
void MakePersistentLength(in vec3 groundPos, inout vec3 v1, inout vec3 v2, in float height) {
    //Persistent length
    vec3 v01 = v1 - groundPos;
    vec3 v12 = v2 - v1;
    float lv01 = length(v01);
    float lv12 = length(v12);


    float L1 = lv01 + lv12;
    float L0 = length(v2 - groundPos);
    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 = groundPos + v01;
    v2 = v1 + v12;
}

//utils https://github.com/GPUOpen-LibrariesAndSDKs/WorkGraphsMeshNodeSample/blob/main/meshNodeSample/shaders/utils.hlsl
uint Hash(uint seed)
{
	seed = (seed ^ 61u) ^ (seed >> 16u);
	seed *= 9u;
	seed = seed ^ (seed >> 4u);
	seed *= 0x27d4eb2du;
	seed = seed ^ (seed >> 15u);
	return seed;
}

uint CombineSeed(uint a, uint b)
{
	return a ^ Hash(b) + 0x9e3779b9 + (a << 6) + (a >> 2);
}

uint CombineSeed(uint a, uint b, uint c)
{
	return CombineSeed(CombineSeed(a, b), c);
}

uint CombineSeed(uint a, uint b, uint c, uint d)
{
	return CombineSeed(CombineSeed(a, b), c, d);
}

uint Hash(in float seed)
{
	return Hash(uint(seed));
}

uint Hash(in vec3 vec)
{
	return CombineSeed(Hash(vec.x), Hash(vec.y), Hash(vec.z));
}

uint Hash(in vec4 vec)
{
	return CombineSeed(Hash(vec.x), Hash(vec.y), Hash(vec.z), Hash(vec.w));
}

float Random(uint seed)
{
	return Hash(seed) / float(~0u);
}

float Random(uint a, uint b)
{
	return Random(CombineSeed(a, b));
}

float Random(uint a, uint b, uint c)
{
	return Random(CombineSeed(a, b), c);
}

float Random(uint a, uint b, uint c, uint d)
{
	return Random(CombineSeed(a, b), c, d);
}

float Random(uint a, uint b, uint c, uint d, uint e)
{
	return Random(CombineSeed(a, b), c, d, e);
}

// https://gpuopen.com/learn/mesh_shaders/mesh_shaders-procedural_grass_rendering/
int tsign(in uint gtid, in int id) {
    return ((gtid & (1u << uint(id))) != 0) ? 1 : -1;
}

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
layout(triangles) out;
layout(max_vertices = 256, max_primitives = 192) out;
void main(){
	SetMeshOutputsEXT(256, 192);

	const int verticesPerBladeEdge = 4;
	const int verticesPerBlade = 2 * verticesPerBladeEdge;
	const int trianglesPerBlade = 6;
	const int maxBladeCount = 32;

	uint overallWorkGroupID = gl_WorkGroupID.x + (gl_WorkGroupID.y * gl_NumWorkGroups.x);

	const vec3 clumpCentre = ssbo.position[overallWorkGroupID].xyz;
	const vec3 clumpNormal = ssbo.groundNormal[overallWorkGroupID].xyz;
	const uint seed = CombineSeed(uint(int(clumpCentre.x / spacing)), uint(int(clumpCentre.z / spacing)));

	const int vertexCount = maxBladeCount * verticesPerBlade;
	const int triangleCount = maxBladeCount * trianglesPerBlade;

	for(uint i = 0; i < 2; ++i){
		int vertID = int(gl_LocalInvocationID.x + gl_WorkGroupSize.x * gl_WorkGroupSize.y * i);

		if(vertID >= vertexCount) break;

		int bladeID = vertID / verticesPerBlade;
		int vertIDLocal = vertID % verticesPerBlade;

		const float height = gdbo.grassHeight + float(Random(seed, bladeID, 20)) * RANDOM_HEIGHT_SCALE;

		vec3 tangent = normalize(cross(vec3(0, 0, 1), clumpNormal));
		vec3 biTangent = normalize(cross(clumpNormal, tangent));

		float bladeDirectionAngle = 2.0 * PI * Random(seed, 4, bladeID);
		vec2 bladeDirection = vec2(cos(bladeDirectionAngle), sin(bladeDirectionAngle)) * gdbo.grassHeight * gdbo.grassLean;

		float offsetAngle = 2.0 * PI * Random(seed, bladeID);
		float offsetRadius = spacing * sqrt(Random(seed, 19, bladeID));
		vec3 bladeOffset = offsetRadius * (cos(offsetAngle) * tangent + sin(offsetAngle) * vec3(0, 0, 1));
		//bladeOffset -= clumpNormal * dot(bladeOffset, clumpNormal);
		//vec3 bladeOffset = offsetRadius * (cos(offsetAngle) * vec3(1, 0, 0) + sin(offsetAngle) * vec3(0, 0, 1));

		vec3 p0 = clumpCentre + bladeOffset;
		vec3 p1 = p0 + vec3(0.0, gdbo.grassHeight, 0.0) + gdbo.controlPointPull.xyz;
		vec3 p2 = p1 + vec3(bladeDirection.x, 0.0, bladeDirection.y);

		MakePersistentLength(p0, p1, p2, gdbo.grassHeight);

		vec3 sideVec = normalize(vec3(bladeDirection.y, 0.0, -bladeDirection.x));
		vec3 offset = tsign(vertIDLocal, 0) * gdbo.bladeThickness * sideVec;

		p0 += offset * 1.0;
		p1 += offset * 0.7;
		p2 += offset * 0.3;

		float t = (vertIDLocal / 2) / float(verticesPerBladeEdge - 1);
		gl_MeshVerticesEXT[vertID].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(p0, p1, p2, t), 1.0);
		normal[vertID] = cross(sideVec, normalize(bezierDerivative(p0, p1, p2, t)));
		fragTexCoord[vertID] = vec2(tsign(vertIDLocal, 0), 0.99 - t);
		clumpNormalOut[vertID] = clumpNormal;
	}

	for(uint i = 0; i < 2; ++i){
		int triID = int(gl_LocalInvocationID.x + gl_WorkGroupSize.x * gl_WorkGroupSize.y * i);
		
		if(triID >= triangleCount) break;

		int bladeID = triID / trianglesPerBlade;
		int triIDLocal = triID % trianglesPerBlade;

		int offset = bladeID * verticesPerBlade + 2 * (triIDLocal / 2);

		uvec3 triangleIndices = (triIDLocal & 1) == 0? uvec3(0, 1, 2) : uvec3(3, 2, 1);

		gl_PrimitiveTriangleIndicesEXT[triID] = offset + triangleIndices;
	}
}

//	float beta = 2.0 * 3.1415 * random(seed);
//
//	float alpha = 2.0 * 3.1415 * random(seed);
//	float bladeRadius = patchRadius * sqrt(random(seed));
//	vec3 bladeOffset = bladeRadius * (cos(alpha) * tangent + sin(alpha) * biTangent);
//
//	vec3 bladePosition = ssbo.position[gl_GlobalInvocationID.x].rgb + bladeOffset;
//
//	float bladeHeight = gdbo.grassHeight + random(seed) * RANDOM_HEIGHT_SCALE;
//
//	vec3 bladeDirection = vec3(0.0, 0.0, 1.0);
//
//	vec3 basePosition = vec3(0.0, 5.0, 0.0);
//	vec3 controlPoint = basePosition + vec3(0.0, gdbo.grassHeight, 0.0) + gdbo.controlPointPull.xyz;
//	vec3 tipPoint = controlPoint + bladeDirection * gdbo.grassHeight * gdbo.grassLean;
//
//	MakePersistentLength(basePosition, controlPoint, tipPoint, gdbo.grassHeight);
//
//	vec3 basePointL = basePosition - vec3(gdbo.bladeThickness, 0.0, 0.0);
//	vec3 basePointR = basePosition + vec3(gdbo.bladeThickness, 0.0, 0.0);
//	vec3 controlPointL = controlPoint - vec3(gdbo.bladeThickness * 0.75, 0.0, 0.0);
//	vec3 controlPointR = controlPoint + vec3(gdbo.bladeThickness * 0.75, 0.0, 0.0);
//	vec3 tipPointL = bezier(basePosition, controlPoint, tipPoint, 0.9) - vec3(gdbo.bladeThickness * 0.5, 0.0, 0.0);
//	vec3 tipPointR = bezier(basePosition, controlPoint, tipPoint, 0.9) + vec3(gdbo.bladeThickness * 0.5, 0.0, 0.0);
//
//	gl_MeshVerticesEXT[0].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(basePointL, controlPointL, tipPointL, 0.0), 1.0);
//	gl_MeshVerticesEXT[1].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(basePointR, controlPointR, tipPointR, 0.0), 1.0);
//	gl_MeshVerticesEXT[2].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(basePointL, controlPointL, tipPointL, 0.25), 1.0);
//	gl_MeshVerticesEXT[3].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(basePointR, controlPointR, tipPointR, 0.25), 1.0);
//	gl_MeshVerticesEXT[4].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(basePointL, controlPointL, tipPointL, 0.5), 1.0);
//	gl_MeshVerticesEXT[5].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(basePointR, controlPointR, tipPointR, 0.5), 1.0);
//	gl_MeshVerticesEXT[6].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(basePointL, controlPointL, tipPointL, 0.75), 1.0);
//	gl_MeshVerticesEXT[7].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(bezier(basePointR, controlPointR, tipPointR, 0.75), 1.0);
//	gl_MeshVerticesEXT[8].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(tipPoint, 1.0);
//
//	gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
//	gl_PrimitiveTriangleIndicesEXT[1] = uvec3(3, 2, 1);
//	gl_PrimitiveTriangleIndicesEXT[2] = uvec3(2, 3, 4);
//	gl_PrimitiveTriangleIndicesEXT[3] = uvec3(5, 4, 3);
//	gl_PrimitiveTriangleIndicesEXT[4] = uvec3(4, 5, 6);
//	gl_PrimitiveTriangleIndicesEXT[5] = uvec3(7, 6, 5);
//	gl_PrimitiveTriangleIndicesEXT[6] = uvec3(8, 7, 6);
//	uint offset = 4 * gl_LocalInvocationID.x;
//
//	gl_MeshVerticesEXT[0 + offset].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(-1.0 + (gl_LocalInvocationID.x * 2), 2.0, 0.0 + (gl_WorkGroupID.x * 2), 1.0);
//	gl_MeshVerticesEXT[1 + offset].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(-1.0 + (gl_LocalInvocationID.x * 2), 4.0, 0.0 + (gl_WorkGroupID.x * 2), 1.0);
//	gl_MeshVerticesEXT[2 + offset].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(1.0 + (gl_LocalInvocationID.x * 2), 4.0, 0.0 + (gl_WorkGroupID.x * 2), 1.0);
//	gl_MeshVerticesEXT[3 + offset].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(1.0 + (gl_LocalInvocationID.x * 2), 2.0, 0.0 + (gl_WorkGroupID.x * 2), 1.0);
//	gl_PrimitiveTriangleIndicesEXT[0 + (offset / 2)] = uvec3(0 + offset, 1 + offset, 2 + offset);
//	gl_PrimitiveTriangleIndicesEXT[1 + (offset / 2)] = uvec3(0 + offset, 2 + offset, 3 + offset);
//}