#version 460
#extension GL_EXT_mesh_shader : require

const uint grassCount = 65536 * 4;
const float RANDOM_HEIGHT_SCALE = 0.7;
const uint clumpRadius = 1;
const float spacing = 1;
const float PI = 3.1415;

layout(set = 0, binding = 0) uniform UniformBufferObject {
	mat4 model;
	mat4 view;
	mat4 proj;
} ubo;

layout(set = 0, binding = 1) uniform GrassDataBufferObject{
	float elapsedTime;
	float grassLean;
	float grassHeight;
	float bladeThickness;
	float curveStrength;
	float windLeanStrength;
	float windSpeed;
	float windOffsetStrength;
	float windDirection;
	float maxDistance;
	float fCullRadius;
	float padding2;
	vec4 camPosition;
	vec4 bezierEndPoint;
} gdbo;

struct blade{
    vec4 position;
    vec2 worldSpaceUV;
};

struct indirectDrawCall{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(set = 1, binding = 0) buffer indirectDrawBuffer{
    indirectDrawCall highLod;
    indirectDrawCall lowLod;
} indirectDraw;

layout(std430, set = 0, binding = 2) readonly buffer GrassPositionsSSBOIn{
	blade bladeInfoHighLod[grassCount];
    blade bladeInfoLowLod[grassCount];
} ssbo;

layout(set = 0, binding = 4) uniform sampler2D noiseSampler;

//struct meshTaskPayload {
//	vec3 col;
//};
//
//taskPayloadSharedEXT meshTaskPayload payload;

layout(location = 0) out vec3 fragColour[];
layout(location = 1) out vec2 fragTexCoord[];
layout(location = 2) out vec3 normal[];
layout(location = 3) out vec3 viewDirection[];

vec3 bezier(vec3 A, vec3 B, vec3 C, float t) {
  vec3 E = mix(A, B, t);
  vec3 F = mix(B, C, t);
  vec3 G = mix(E, F, t);

  return G;
}

vec3 bezierDerivative(vec3 p0, vec3 p1, vec3 p2, float t) {
    return 2.0 * (1.0 - t) * (p1 - p0) + 2.0 * t * (p2 - p1);
}

// https://github.com/klejah/ResponsiveGrassDemo/blob/6ce514717467acc80fd965a6f7695d5151ba8c03/ResponsiveGrassDemo/shader/Grass/GrassUpdateForcesShader.cs#L67
void MakePersistentLength(in vec3 groundPos, inout vec3 v1, inout vec3 v2, in float height) {
    //Persistent length
    vec3 v01 = v1 - groundPos;
    vec3 v12 = v2 - v1;
    float lv01 = length(v01);
    float lv12 = length(v12);


    float L1 = lv01 + lv12;
    float L0 = length(v2 - groundPos);
    float L = (2.0 * L0 + L1) / 3.0; //http://steve.hollasch.net/cgindex/curves/cbezarclen.html

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 = groundPos + v01;
    v2 = v1 + v12;
}

//utils https://github.com/GPUOpen-LibrariesAndSDKs/WorkGraphsMeshNodeSample/blob/main/meshNodeSample/shaders/utils.hlsl

uint Hash(uint seed)
{
	seed = (seed ^ 61u) ^ (seed >> 16u);
	seed *= 9u;
	seed = seed ^ (seed >> 4u);
	seed *= 0x27d4eb2du;
	seed = seed ^ (seed >> 15u);
	return seed;
}

uint CombineSeed(uint a, uint b)
{
	return a ^ Hash(b) + 0x9e3779b9 + (a << 6) + (a >> 2);
}

uint CombineSeed(uint a, uint b, uint c)
{
	return CombineSeed(CombineSeed(a, b), c);
}

uint CombineSeed(uint a, uint b, uint c, uint d)
{
	return CombineSeed(CombineSeed(a, b), c, d);
}

uint Hash(in float seed)
{
	return Hash(uint(seed));
}

uint Hash(in vec3 vec)
{
	return CombineSeed(Hash(vec.x), Hash(vec.y), Hash(vec.z));
}

uint Hash(in vec4 vec)
{
	return CombineSeed(Hash(vec.x), Hash(vec.y), Hash(vec.z), Hash(vec.w));
}

float Random(uint seed)
{
	return Hash(seed) / float(~0u);
}

float Random(uint a, uint b)
{
	return Random(CombineSeed(a, b));
}

float Random(uint a, uint b, uint c)
{
	return Random(CombineSeed(a, b), c);
}

float Random(uint a, uint b, uint c, uint d)
{
	return Random(CombineSeed(a, b), c, d);
}

float Random(uint a, uint b, uint c, uint d, uint e)
{
	return Random(CombineSeed(a, b), c, d, e);
}

// https://gpuopen.com/learn/mesh_shaders/mesh_shaders-procedural_grass_rendering/
int tsign(in uint gtid, in int id) {
    return ((gtid & (1u << uint(id))) != 0) ? 1 : -1;
}

// https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9
float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

// https://www.shadertoy.com/view/wtcczf
float EaseInSine(float x)
{
    return 1.0 - cos((x * PI) / 2.0);
}

vec3 calculateWindOffset(vec2 uv){
	float windDirection = texture(noiseSampler, uv * 0.05 * 0.05 * gdbo.elapsedTime).r;
	windDirection = map(windDirection, -1.0, 1.0, 0.0, PI * 2.0);
	vec2 windDirectionVec = vec2(cos(windDirection), sin(windDirection));

	float windStrength = texture(noiseSampler, uv * 0.25 + gdbo.elapsedTime).r;

	float windLeanAngle = map(windStrength, -1.0, 1.0, 0.25, 1.0);
	windLeanAngle = EaseInSine(windLeanAngle) * 1.25;

	return vec3(windDirectionVec.x, 0, windDirectionVec.y) * windLeanAngle;
}

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
layout(triangles) out;
layout(max_vertices = 256, max_primitives = 192) out;
void main(){
	uint overallWorkGroupID = (gl_WorkGroupID.x + (gl_WorkGroupID.y * gl_NumWorkGroups.x) + (gl_WorkGroupID.z * gl_NumWorkGroups.y * gl_NumWorkGroups.x));

	uint highLodCount = indirectDraw.highLod.instanceCount / 4;
	uint lowLodCount = indirectDraw.lowLod.instanceCount / 4;

	if(overallWorkGroupID >= (highLodCount + lowLodCount)){
		SetMeshOutputsEXT(0, 0);
		return;
	}

	vec3 clumpCentre;
	vec2 clumpUV;

	if(overallWorkGroupID < highLodCount) { 
		clumpCentre = ssbo.bladeInfoHighLod[overallWorkGroupID].position.xyz;	
		clumpUV = ssbo.bladeInfoHighLod[overallWorkGroupID].worldSpaceUV;
	} else {
		clumpCentre = ssbo.bladeInfoLowLod[overallWorkGroupID - highLodCount].position.xyz;	
		clumpUV = ssbo.bladeInfoLowLod[overallWorkGroupID - highLodCount].worldSpaceUV;
	}

	//const vec3 clumpNormal = texture(normalSampler, ssbo.bladeInfo[overallWorkGroupID].worldSpaceUV).rgb;
	const vec3 clumpNormal = vec3(0, 1, 0);
	const vec2 noiseSample = texture(noiseSampler, clumpUV).rg;
	const uint seed = CombineSeed(int(noiseSample.r * 1000), int(clumpCentre.x * 1000), int(clumpCentre.z * 1000));

	const int maxVerticesPerBladeEdge = 16;
	const int minVerticesPerBladeEdge = 3;

	float distanceFromCam = abs(length(gdbo.camPosition.xyz - clumpCentre));
	float maxDistanceFromCam = gdbo.maxDistance;
	const int actualVerticesPerBladeEdge = max(int(mix(maxVerticesPerBladeEdge, minVerticesPerBladeEdge, clamp(distanceFromCam / maxDistanceFromCam, 0.0, 1.0)) / 2) * 2, minVerticesPerBladeEdge);

	const int verticesPerBlade = 2 * actualVerticesPerBladeEdge;
	const int trianglesPerBlade = 2 * (actualVerticesPerBladeEdge - 1);
	const int maxBladeCount = 4;

	const int vertexCount = maxBladeCount * verticesPerBlade;
	const int triangleCount = maxBladeCount * trianglesPerBlade;

	SetMeshOutputsEXT(vertexCount, triangleCount);

	for(uint i = 0; i < 2; ++i){
		int vertID = int(gl_LocalInvocationID.x + gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * i);

		if(vertID >= vertexCount) break;

		int bladeID = vertID / verticesPerBlade;
		int vertIDLocal = vertID % verticesPerBlade;

		const float height = gdbo.grassHeight + float(Random(seed, bladeID, 20)) * RANDOM_HEIGHT_SCALE;

		vec3 tangent = normalize(cross(vec3(0, 0, 1), clumpNormal));
		vec3 biTangent = normalize(cross(clumpNormal, tangent));

		float grassLeanStrength = gdbo.grassLean * gdbo.windLeanStrength * texture(noiseSampler, (clumpUV * 3.0) - (gdbo.elapsedTime * vec2(cos(gdbo.windDirection), sin(gdbo.windDirection)) * gdbo.windSpeed)).r;
		float bladeDirectionAngle = mix(2.0 * PI * Random(seed, 4, bladeID), gdbo.windDirection, 0.9);
		vec2 bladeDirection = vec2(cos(bladeDirectionAngle), sin(bladeDirectionAngle)) * gdbo.grassHeight * grassLeanStrength;

		float offsetAngle = 2.0 * PI * Random(seed, bladeID);
		float offsetRadius = spacing * sqrt(Random(seed, 19, bladeID));
		vec3 bladeOffset = offsetRadius * (cos(offsetAngle) * tangent + sin(offsetAngle) * vec3(0, 0, 1));
		//bladeOffset -= clumpNormal * dot(bladeOffset, clumpNormal);
		//vec3 bladeOffset = offsetRadius * (cos(offsetAngle) * vec3(1, 0, 0) + sin(offsetAngle) * vec3(0, 0, 1));

		vec3 sideVec = normalize(vec3(bladeDirection.y, 0.0, -bladeDirection.x));
		vec3 offset = tsign(vertIDLocal, 0) * gdbo.bladeThickness * sideVec;

		vec3 p0 = clumpCentre + bladeOffset;
		vec3 p2 = p0 + vec3(0.0, gdbo.grassHeight, 0.0) + vec3(bladeDirection.x, 0.0, bladeDirection.y);
		vec3 p1 = p0 + ((p2 - p0) * 0.75) + cross(((p2 - p0) * 0.75), sideVec) * gdbo.curveStrength;

		MakePersistentLength(p0, p1, p2, gdbo.grassHeight);

		vec3 basePoint = p0;

		p0 += offset * 1.0;
		p1 += offset * 0.9;
		//p2 += offset * 0.1;

		int edgeID = vertIDLocal / 2;
		float t = (edgeID == actualVerticesPerBladeEdge - 1) ? 1.0 : float(edgeID) / float(actualVerticesPerBladeEdge - 1);
		vec3 vertexNormal = normalize(cross(sideVec, normalize(bezierDerivative(p0, p1, p2, t))));
		//vec3 windOffset = vertexNormal * (sin(t + bladeID + gdbo.elapsedTime * gdbo.windSpeed) - 0.5) * texture(noiseSampler, (clumpUV * 3.0) + (gdbo.elapsedTime * gdbo.windSpeed)).r * (t * t) * gdbo.windOffsetStrength;
		vec3 vertexPos = bezier(p0, p1, p2, t);
		//vertexPos += windOffset;
		gl_MeshVerticesEXT[vertID].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(vertexPos, 1.0);
		normal[vertID] = mix(vertexNormal, offset, 0.4);
		fragTexCoord[vertID] = vec2(tsign(vertIDLocal, 0), 1.0 - t);

		vec3 viewDir = normalize(gdbo.camPosition.rgb - vertexPos);

		viewDirection[vertID] = viewDir;

		int colourOut = int(gdbo.camPosition.w);

		if(colourOut == 0){
			fragColour[vertID] = vec3(1, 1, 1);
		}
		else if(colourOut == 2){
			fragColour[vertID] = vec3(clamp(float(actualVerticesPerBladeEdge) / float(maxVerticesPerBladeEdge), 0.0, 1.0));
		}
		else if(colourOut == 3){
			fragColour[vertID] = vec3(Random(overallWorkGroupID), Random(overallWorkGroupID + 1), Random(overallWorkGroupID + 2));
		}
		else if(colourOut == 4){
			fragColour[vertID] = vec3(1, 1, 1);
		}
	}

	for(uint i = 0; i < 2; ++i){
		int triID = int(gl_LocalInvocationID.x + gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * i);
		
		if(triID >= triangleCount) break;

		int bladeID = triID / trianglesPerBlade;
		int triIDLocal = triID % trianglesPerBlade;

		int offset = bladeID * verticesPerBlade + 2 * (triIDLocal / 2);

		uvec3 triangleIndices = (triIDLocal & 1) == 0? uvec3(0, 1, 2) : uvec3(3, 2, 1);

		gl_PrimitiveTriangleIndicesEXT[triID] = offset + triangleIndices;
	}
}