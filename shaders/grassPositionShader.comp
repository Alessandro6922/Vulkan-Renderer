/*
    TODO: Add a little random offset to the position controllable through a buffer (just repurpose the spacing variable cause we aint using that anymore fr
*/

#version 460

const uint grassCount = 1638400;
const uint gridSize = uint(sqrt(grassCount)); // 128
const uint planeSize = 500; // -25 to 25 in each direction
const float scalingFactor = float(planeSize) / float(gridSize);
const float randomOffsetScale = 4.0;

layout(std430, set = 0, binding = 2) buffer bufferGrassPositionsSSBO{
    vec4 positionsOut[];
}ssbo;

layout(set = 1, binding = 1) uniform sampler2D displacementSampler;
layout(set = 0, binding = 4) uniform sampler2D noiseSampler;

float randomOffset(uint instanceIndex){
	return fract(sin(float(instanceIndex) * 12.9898) * 43758.5453) - 0.5;
}

float randomAngle(uint instanceIndex){
	return fract(sin(float(instanceIndex) * 12.9898) * 43758.5453) * 360.0;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main(){
    uint threadID = gl_GlobalInvocationID.x;

    uint gridX = (threadID % gridSize);
    uint gridZ = (threadID / gridSize);

    vec2 uv = vec2(float(gridX) / float(gridSize), float(gridZ) / float(gridSize));
    
    int centredX = int(gridX) - 640;
    int centredZ = int(gridZ) - 640;

    float finalX = float(centredX) * scalingFactor;
    finalX += randomOffset(threadID) * randomOffsetScale;
    float finalZ = float(centredZ) * scalingFactor;
    finalZ += randomOffset(threadID) * randomOffsetScale;

    float height = 500 * texture(displacementSampler, uv).g;

    float randomRotation = randomAngle(threadID);

    float sampledRotation = texture(noiseSampler, uv).r * 360.0; // ill sort this later

    float windDirectionAngle = 6.0;

    float rotation = mix(mix(randomRotation, sampledRotation, 0.3), windDirectionAngle, 0.8);

    ssbo.positionsOut[threadID] = vec4(finalX, height, finalZ, rotation);
}