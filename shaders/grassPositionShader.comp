/*
    TODO: Add a little random offset to the position controllable through a buffer (just repurpose the spacing variable cause we aint using that anymore fr
*/

#version 460

const uint grassCount = 65536 * 4;
const uint gridSize = uint(sqrt(grassCount));
const uint planeSize = 500;
const float scalingFactor = float(planeSize) / float(gridSize);
const float randomOffsetScale = 4.0;

layout(set = 0, binding = 0) uniform UniformBufferObject {
	mat4 model;
	mat4 view;
	mat4 proj;
} ubo;

struct blade{
    vec4 position;
    vec2 worldSpaceUV;
};

layout(std430, set = 0, binding = 2) buffer bufferGrassPositionsSSBO{
    blade bladeInfo[grassCount];
}ssbo;

layout(set = 1, binding = 1) uniform sampler2D displacementSampler;
layout(set = 1, binding = 2) uniform sampler2D normalSampler;
layout(set = 0, binding = 4) uniform sampler2D noiseSampler;

float randomOffset(uint instanceIndex){
	return fract(sin(float(instanceIndex) * 12.9898) * 43758.5453) - 0.5;
}

float randomAngle(uint instanceIndex){
	return fract(sin(float(instanceIndex) * 12.9898) * 43758.5453) * 360.0;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main(){
    uint threadID = gl_GlobalInvocationID.x;

    uint gridX = (threadID % gridSize);
    uint gridZ = (threadID / gridSize);
    
    float offsetX = float(gridX) + randomOffset(threadID) * float(1 / gridSize) * randomOffsetScale;
    float offsetZ = float(gridZ) + randomOffset(threadID) * float(1 / gridSize) * randomOffsetScale;

    vec2 uv = vec2(float(offsetX) / float(gridSize), float(offsetZ) / float(gridSize));

    int centredX = int(offsetX) - int(gridSize / 2);// - 640;
    int centredZ = int(offsetZ) - int(gridSize / 2);// - 640;

    float finalX = float(centredX) * scalingFactor;
    float finalZ = float(centredZ) * scalingFactor;

    float height = 500 * texture(displacementSampler, uv).g;

    // normals are just not right i so cannot be fucked fixing this right now i feel like im chasing a never ending thread i do not know what the root cause is
    vec3 normal = texture(normalSampler, uv).rgb;
    
    float randomRotation = randomAngle(threadID);

    float sampledRotation = texture(noiseSampler, uv).r * 360.0; // ill sort this later

    float windDirectionAngle = 6.0;

    float rotation = mix(mix(randomRotation, sampledRotation, 0.3), windDirectionAngle, 0.8);

    ssbo.bladeInfo[threadID].position = vec4(finalX, height, finalZ, rotation);
    ssbo.bladeInfo[threadID].worldSpaceUV = uv;
}